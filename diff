diff --git a/.test.c.swp b/.test.c.swp
new file mode 100644
index 0000000..7d03001
Binary files /dev/null and b/.test.c.swp differ
diff --git a/Makefile b/Makefile
index 09d790c..8b073ac 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -251,6 +252,7 @@ EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
 	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
 	printf.c umalloc.c\
+	test.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
 
diff --git a/fcntl.h b/fcntl.h
index d565483..904b7f6 100644
--- a/fcntl.h
+++ b/fcntl.h
@@ -2,3 +2,4 @@
 #define O_WRONLY  0x001
 #define O_RDWR    0x002
 #define O_CREATE  0x200
+#define O_CS 0x020
diff --git a/fs.c b/fs.c
index f77275f..30e2f43 100644
--- a/fs.c
+++ b/fs.c
@@ -77,6 +77,103 @@ balloc(uint dev)
   panic("balloc: out of blocks");
 }
 
+// [20172644] CS를 위한 block 할당 함수
+static uint
+bcsalloc(uint dev, int prevbnum, uint needlen, uint *alloclen)
+{
+  int b, bi, m;
+  struct buf *bp;
+  bp = 0;
+  if(prevbnum == -1){ // [20172644] 완전히 새로운 영역을 할당하려고 할때
+	b=0;
+	bi=0;
+  }
+  else{ // [20172644] 이전 영역에 이어서 할당하려고 할 때
+	int nextbnum = prevbnum+1;
+	b = nextbnum / BPB;
+	bi = nextbnum % BPB;
+  }
+  int staddr = -1;
+  int length = 0;
+  int modified;
+  while(b < sb.size){
+    bp = bread(dev, BBLOCK(b, sb));
+	modified = 0;
+	while(bi < BPB && b+bi < sb.size){
+      m = 1 << (bi % 8);
+	  if(prevbnum == -1) {  // [20172644] 완전히 새로운 영역을 할당하는 경우
+		if((bp->data[bi/8] & m) == 0) {  // [20172644] Is block free?
+		  if(staddr == -1)
+			staddr = b+bi;
+		  bp->data[bi/8] |= m;  // [20172644]  Mark block in use.
+		  modified = 1;
+		  length++;
+		  if(needlen <= length){
+			log_write(bp);
+			brelse(bp);
+			for(int i = staddr; i < b + bi; i++)
+			  bzero(dev, i);
+			*alloclen = length;
+			return staddr;
+		  }
+		}
+		else if(staddr != -1){ // [20172644] end sequence
+		  log_write(bp);
+		  brelse(bp);
+		  for(int i = staddr; i < b + bi; i++)
+			bzero(dev, i);
+		  *alloclen = length;
+		  return staddr;
+		}
+	  }
+	  else { // [20172644] 이전 공간에 이어서 할당하는 경우
+		if((bp->data[bi/8] & m) == 0) {  //  [20172644] Is block free?
+		  if(staddr == -1)
+			staddr = b+bi;
+		  bp->data[bi/8] |= m;  // [20172644]  Mark block in use.
+		  modified = 1;
+		  length++;
+		  if(needlen <= length){
+			log_write(bp);
+			brelse(bp);
+			for(int i = staddr; i < b + bi; i++)
+			  bzero(dev, i);
+			*alloclen = length;
+			return staddr;
+		  }
+		}
+		else{ // [20172644] not free
+		  if(staddr == -1){ // [20172644] not sequence
+			brelse(bp);
+			return -1;
+		  }
+		  else{  // [20172644] sequence
+			log_write(bp);
+			brelse(bp);
+			for(int i = staddr; i < b + bi; i++) 
+			  bzero(dev, i);
+			*alloclen = length;
+			return staddr;
+		  }
+		}
+	  }
+	  ++bi;
+	}
+	if(modified){ //[20172644] 변경 사항 적용
+	  log_write(bp);
+	  brelse(bp);
+	  for(int i = staddr; i < b + bi; i++)
+		bzero(dev, i);
+	}
+	else{
+	  brelse(bp);
+	}
+	b += BPB;
+	bi=0;
+  }
+  panic("balloc: out of blocks");
+}
+
 // Free a disk block.
 static void
 bfree(int dev, uint b)
@@ -399,6 +496,64 @@ bmap(struct inode *ip, uint bn)
   panic("bmap: out of range");
 }
 
+// [20172644] CS를 위한 블록 매핑 함수
+static uint
+bcsmap(struct inode *ip, uint off, uint n)
+{
+  uint staddr;
+  uint prevaddr;
+  uint alloclen;
+
+  uint bn;
+  uint position = off/BSIZE;
+  uint accum;
+  uint seqlen;
+  uint needlen = n % BSIZE ? n / BSIZE + 1 : n / BSIZE;
+
+  for(bn = 0, accum = 0 ; bn < NDIRECT && ip->addrs[bn] ; bn++){
+	accum += ip->addrs[bn] & 255; // [20172644] accum 변수에 길이를 더함
+	if(accum > position){ // [20172644] 위치 발견
+	  accum -= ip->addrs[bn] & 255;
+	  return (ip->addrs[bn] >> 8) + (position - accum); // [20172644] 블럭의 위치를 리턴
+	}
+  }
+
+  if(bn != 0){ // [20172644] 마지막 addrs 확장
+	accum -= ip->addrs[bn-1] & 255; 
+	staddr = ip->addrs[bn-1] >> 8;
+	alloclen = ip->addrs[bn-1] & 255;
+	if(alloclen < 255){ // [20172644] 255 미만일때만 확장 가능
+	  prevaddr = staddr+alloclen - 1;
+	  int b;
+	  if(255-alloclen < needlen)
+		b = bcsalloc(ip->dev, prevaddr, 255-alloclen, &seqlen);
+	  else
+		b = bcsalloc(ip->dev, prevaddr, needlen, &seqlen);
+	  if(b != -1){ // [20172644] 확장 성공
+		alloclen += seqlen;
+		ip->addrs[bn-1] = (staddr << 8) | (alloclen & 255);
+		if(accum + alloclen > position){ // [20172644] 데이터를 위치시킬 공간을 얻었다면
+		  return staddr + (position - accum);
+		}
+	  }
+	}
+	accum += alloclen;
+  }
+
+  if(bn >= NDIRECT){ // [20172644] 용량초과
+	panic("bcsmap: Exceeded the maximum file size.");
+	return -1;
+  }
+
+  if(needlen <= 255) // [20172644] 최대 연속 할당 길이는 255
+	staddr = bcsalloc(ip->dev, -1, needlen, &seqlen); 
+  else
+	staddr = bcsalloc(ip->dev, -1, 255, &seqlen); 
+  alloclen = seqlen;
+  ip->addrs[bn] = (staddr << 8) | (alloclen & 255);
+  return staddr + (position - accum);
+}
+
 // Truncate inode (discard contents).
 // Only called when the inode has no links
 // to it (no directory entries referring to it)
@@ -409,29 +564,44 @@ itrunc(struct inode *ip)
 {
   int i, j;
   struct buf *bp;
+  uint addr, length;
   uint *a;
-
-  for(i = 0; i < NDIRECT; i++){
-    if(ip->addrs[i]){
-      bfree(ip->dev, ip->addrs[i]);
-      ip->addrs[i] = 0;
-    }
+  if(ip->type == T_CS){ // [20172644] CS 시스템 전용 삭제 처리
+	for(i = 0; i < NDIRECT; i++){
+	  if(ip->addrs[i]){
+		addr = ip->addrs[i] >> 8;
+		length = ip->addrs[i] & 255;
+		for(j = 0 ; j < length ; j++)
+		  bfree(ip->dev, addr+BSIZE*j);
+		ip->addrs[i] = 0;
+	  }
+	}
+	ip->size = 0;
+	iupdate(ip);
   }
-
-  if(ip->addrs[NDIRECT]){
-    bp = bread(ip->dev, ip->addrs[NDIRECT]);
-    a = (uint*)bp->data;
-    for(j = 0; j < NINDIRECT; j++){
-      if(a[j])
-        bfree(ip->dev, a[j]);
-    }
-    brelse(bp);
-    bfree(ip->dev, ip->addrs[NDIRECT]);
-    ip->addrs[NDIRECT] = 0;
+  else{
+	for(i = 0; i < NDIRECT; i++){
+	  if(ip->addrs[i]){
+		bfree(ip->dev, ip->addrs[i]);
+		ip->addrs[i] = 0;
+	  }
+	}
+
+	if(ip->addrs[NDIRECT]){
+	  bp = bread(ip->dev, ip->addrs[NDIRECT]);
+	  a = (uint*)bp->data;
+	  for(j = 0; j < NINDIRECT; j++){
+		if(a[j])
+		  bfree(ip->dev, a[j]);
+	  }
+	  brelse(bp);
+	  bfree(ip->dev, ip->addrs[NDIRECT]);
+	  ip->addrs[NDIRECT] = 0;
+	}
+
+	ip->size = 0;
+	iupdate(ip);
   }
-
-  ip->size = 0;
-  iupdate(ip);
 }
 
 // Copy stat information from inode.
@@ -466,21 +636,34 @@ readi(struct inode *ip, char *dst, uint off, uint n)
   if(off + n > ip->size)
     n = ip->size - off;
 
-  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(dst, bp->data + off%BSIZE, m);
-    brelse(bp);
+  // [20172644] readi for cs
+  if(ip->type == T_CS){
+	for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+	  bp = bread(ip->dev, bcsmap(ip, off, n-tot));
+	  m = min(n - tot, BSIZE - off%BSIZE);
+	  memmove(dst, bp->data + off%BSIZE, m);
+	  brelse(bp);
+	}
+  }
+  else{
+	for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+	  bp = bread(ip->dev, bmap(ip, off/BSIZE));
+	  m = min(n - tot, BSIZE - off%BSIZE);
+	  memmove(dst, bp->data + off%BSIZE, m);
+	  brelse(bp);
+	}
   }
   return n;
 }
 
+
 // PAGEBREAK!
 // Write data to inode.
 // Caller must hold ip->lock.
 int
 writei(struct inode *ip, char *src, uint off, uint n)
 {
+
   uint tot, m;
   struct buf *bp;
 
@@ -492,20 +675,33 @@ writei(struct inode *ip, char *src, uint off, uint n)
 
   if(off > ip->size || off + n < off)
     return -1;
-  if(off + n > MAXFILE*BSIZE)
-    return -1;
 
-  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
-    bp = bread(ip->dev, bmap(ip, off/BSIZE));
-    m = min(n - tot, BSIZE - off%BSIZE);
-    memmove(bp->data + off%BSIZE, src, m);
-    log_write(bp);
-    brelse(bp);
+  // [20172644] writei for cs
+  if(ip->type == T_CS){
+	for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+	  bp = bread(ip->dev, bcsmap(ip, off, n-tot));
+	  m = min(n - tot, BSIZE - off%BSIZE);
+	  memmove(bp->data + off%BSIZE, src, m);
+	  log_write(bp);
+	  brelse(bp);
+	}
+  }
+  else {
+	if(off + n > MAXFILE*BSIZE)
+	  return -1;
+
+	for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+	  bp = bread(ip->dev, bmap(ip, off/BSIZE));
+	  m = min(n - tot, BSIZE - off%BSIZE);
+	  memmove(bp->data + off%BSIZE, src, m);
+	  log_write(bp);
+	  brelse(bp);
+	}
   }
 
   if(n > 0 && off > ip->size){
-    ip->size = off;
-    iupdate(ip);
+	ip->size = off;
+	iupdate(ip);
   }
   return n;
 }
diff --git a/stat.h b/stat.h
index 8a80933..37e239c 100644
--- a/stat.h
+++ b/stat.h
@@ -1,6 +1,7 @@
 #define T_DIR  1   // Directory
 #define T_FILE 2   // File
 #define T_DEV  3   // Device
+#define T_CS 4	   // Continuous Sector based File
 
 struct stat {
   short type;  // Type of file
diff --git a/syscall.c b/syscall.c
index ee85261..d621b27 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_printinfo(void); // [20172644] printinfo
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_printinfo]   sys_printinfo,  // [20172644] printinfo
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..e9b2350 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_printinfo  22
diff --git a/sysfile.c b/sysfile.c
index bfe61b7..b652544 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -253,6 +253,9 @@ create(char *path, short type, short major, short minor)
     ilock(ip);
     if(type == T_FILE && ip->type == T_FILE)
       return ip;
+	else if(type == T_CS && ip->type == T_CS)
+	  // [20172644] CS 처리
+      return ip;
     iunlockput(ip);
     return 0;
   }
@@ -296,22 +299,26 @@ sys_open(void)
   begin_op();
 
   if(omode & O_CREATE){
-    ip = create(path, T_FILE, 0, 0);
-    if(ip == 0){
-      end_op();
-      return -1;
-    }
+    // [20172644] CS 처리
+	if(omode & O_CS)
+	  ip = create(path, T_CS, 0, 0);
+	else
+	  ip = create(path, T_FILE, 0, 0);
+	if(ip == 0){
+	  end_op();
+	  return -1;
+	}
   } else {
-    if((ip = namei(path)) == 0){
-      end_op();
-      return -1;
-    }
-    ilock(ip);
-    if(ip->type == T_DIR && omode != O_RDONLY){
-      iunlockput(ip);
-      end_op();
-      return -1;
-    }
+	if((ip = namei(path)) == 0){
+	  end_op();
+	  return -1;
+	}
+	ilock(ip);
+	if(ip->type == T_DIR && omode != O_RDONLY){
+	  iunlockput(ip);
+	  end_op();
+	  return -1;
+	}
   }
 
   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
@@ -442,3 +449,40 @@ sys_pipe(void)
   fd[1] = fd1;
   return 0;
 }
+
+//[20172644] printinfo
+int
+sys_printinfo(void)
+{
+  struct file *f;
+  char *fname;
+  if(argfd(0, 0, &f) < 0 || argstr(1, &fname) < 0)
+    return -1;
+  
+  int num, length;
+  struct inode *ip = f->ip;
+  const char *typestr[] = {"X", "DIR", "FILE", "DEV", "CS"};
+  cprintf("FILE NAME: %s\n", fname);
+  cprintf("INODE NUM: %d\n", ip->inum);
+  cprintf("FILE TYPE: %s\n", typestr[ip->type]);
+  cprintf("FILE SIZE: %d Bytes\n", ip->size);
+  cprintf("DIRECT BLOCK INFO:\n");
+  if(ip->type == T_FILE){
+	for(int i = 0 ; i < NDIRECT ; i++){
+	  if(ip->addrs[i])
+		cprintf("[%d] %d\n",i,ip->addrs[i]);
+	}
+  }
+  else if(ip->type == T_CS){
+	for(int i = 0 ; i < NDIRECT ; i++){
+	  if(!ip->addrs[i])
+		continue;
+	  num = ip->addrs[i] >> 8;
+	  length = ip->addrs[i] & 255;
+	  cprintf("[%d] %d (num: %d, length: %d)\n",
+		i, ip->addrs[i], num, length);
+	}
+  }
+  cprintf("\n");
+  return 0;
+}
diff --git a/test.c b/test.c
new file mode 100644
index 0000000..90afdb2
--- /dev/null
+++ b/test.c
@@ -0,0 +1,72 @@
+#include "types.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+#include "fcntl.h"
+#include "user.h"
+
+#define BUFMAX 1024
+
+void write_to_norm(char* fname);
+
+int main()
+{
+	int fd;
+	int i, size;
+	char buf[BUFMAX];
+	char* fname = "test_cs";
+
+	if ((fd = open(fname, O_CREATE | O_CS | O_RDWR)) <= 0) {
+		printf(2, "ERROR: open failed in cs file\n");
+		exit();
+	}
+
+	for (i = 0; i < BUFMAX; i++)
+		buf[i] = 'a';
+
+	for (i = 0; i < 130; i++) {
+		if ((size = write(fd, buf, BUFMAX)) != BUFMAX) {
+			printf(2, "ERROR: write failed in cs file\n");
+			exit();
+		}
+
+		if (i == 50)
+			write_to_norm("test_norm");	
+	}
+
+	printinfo(fd, fname);
+	
+	close(fd);
+	exit();
+}
+
+void write_to_norm(char* fname)
+{
+	int fd;
+	int i, size;
+	char buf[BUFMAX];
+
+	if ((fd = open(fname, O_CREATE | O_RDWR)) <= 0) {
+		printf(2, "ERROR: open failed in normal file\n");
+		exit();
+	}
+
+	for (i = 0; i < BUFMAX; i++)
+		buf[i] = 'b';
+
+	for (i = 0; i < 2; i++) {
+		if ((size = write(fd, buf, BUFMAX)) != BUFMAX) {
+			printf(2, "ERROR: write failed in normal file\n");
+			exit();
+		}
+	}
+
+	printinfo(fd, fname);
+	
+	close(fd);
+}
diff --git a/test2.c b/test2.c
new file mode 100644
index 0000000..a57a6b1
--- /dev/null
+++ b/test2.c
@@ -0,0 +1,74 @@
+#include "types.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+#include "fcntl.h"
+#include "user.h"
+
+#define BUFMAX 1024
+
+void write_to_norm(char* fname);
+
+int main()
+{
+	int fd;
+	int i, size;
+	char buf[BUFMAX];
+	char* fname = "test_cs";
+
+	if ((fd = open(fname, O_CREATE | O_CS | O_RDWR)) <= 0) {
+		printf(2, "ERROR: open failed in cs file\n");
+		exit();
+	}
+
+	for (i = 0; i < BUFMAX; i++)
+		buf[i] = 'a';
+
+	for (i = 0; i < 130; i++) {
+		if ((size = write(fd, buf, BUFMAX)) != BUFMAX) {
+			printf(2, "ERROR: write failed in cs file\n");
+			exit();
+		}
+
+		/*	
+		if (i == 50)
+			write_to_norm("test_norm");	
+		*/
+	}
+
+	printinfo(fd, fname);
+	
+	close(fd);
+	exit();
+}
+
+void write_to_norm(char* fname)
+{
+	int fd;
+	int i, size;
+	char buf[BUFMAX];
+
+	if ((fd = open(fname, O_CREATE | O_RDWR)) <= 0) {
+		printf(2, "ERROR: open failed in normal file\n");
+		exit();
+	}
+
+	for (i = 0; i < BUFMAX; i++)
+		buf[i] = 'b';
+
+	for (i = 0; i < 2; i++) {
+		if ((size = write(fd, buf, BUFMAX)) != BUFMAX) {
+			printf(2, "ERROR: write failed in normal file\n");
+			exit();
+		}
+	}
+
+	printinfo(fd, fname);
+	
+	close(fd);
+}
diff --git a/user.h b/user.h
index 4f99c52..77154ce 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int printinfo(int, const char*); // [20172644] printinfo
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..0d3023f 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(printinfo)
